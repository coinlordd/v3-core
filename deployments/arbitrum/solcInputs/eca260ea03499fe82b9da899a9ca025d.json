{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/constants/ConstantsInternal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { Decimal } from \"../libraries/LibDecimal.sol\";\r\nimport { ConstantsStorage } from \"./ConstantsStorage.sol\";\r\nimport { IConstantsEvents } from \"./IConstantsEvents.sol\";\r\n\r\nlibrary ConstantsInternal {\r\n    using ConstantsStorage for ConstantsStorage.Layout;\r\n    using Decimal for Decimal.D256;\r\n\r\n    uint256 private constant PERCENT_BASE = 1e18;\r\n    uint256 private constant PRECISION = 1e18;\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function getPrecision() internal pure returns (uint256) {\r\n        return PRECISION;\r\n    }\r\n\r\n    function getPercentBase() internal pure returns (uint256) {\r\n        return PERCENT_BASE;\r\n    }\r\n\r\n    function getCollateral() internal view returns (address) {\r\n        return ConstantsStorage.layout().collateral;\r\n    }\r\n\r\n    function getLiquidationFee() internal view returns (Decimal.D256 memory) {\r\n        return Decimal.ratio(ConstantsStorage.layout().liquidationFee, PERCENT_BASE);\r\n    }\r\n\r\n    function getProtocolLiquidationShare() internal view returns (Decimal.D256 memory) {\r\n        return Decimal.ratio(ConstantsStorage.layout().protocolLiquidationShare, PERCENT_BASE);\r\n    }\r\n\r\n    function getCVA() internal view returns (Decimal.D256 memory) {\r\n        return Decimal.ratio(ConstantsStorage.layout().cva, PERCENT_BASE);\r\n    }\r\n\r\n    function getRequestTimeout() internal view returns (uint256) {\r\n        return ConstantsStorage.layout().requestTimeout;\r\n    }\r\n\r\n    function getMaxOpenPositionsCross() internal view returns (uint256) {\r\n        return ConstantsStorage.layout().maxOpenPositionsCross;\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    function setCollateral(address collateral) internal {\r\n        ConstantsStorage.layout().collateral = collateral;\r\n    }\r\n\r\n    function setLiquidationFee(uint256 liquidationFee) internal {\r\n        ConstantsStorage.layout().liquidationFee = liquidationFee;\r\n    }\r\n\r\n    function setProtocolLiquidationShare(uint256 protocolLiquidationShare) internal {\r\n        ConstantsStorage.layout().protocolLiquidationShare = protocolLiquidationShare;\r\n    }\r\n\r\n    function setCVA(uint256 cva) internal {\r\n        ConstantsStorage.layout().cva = cva;\r\n    }\r\n\r\n    function setRequestTimeout(uint256 requestTimeout) internal {\r\n        ConstantsStorage.layout().requestTimeout = requestTimeout;\r\n    }\r\n\r\n    function setMaxOpenPositionsCross(uint256 maxOpenPositionsCross) internal {\r\n        ConstantsStorage.layout().maxOpenPositionsCross = maxOpenPositionsCross;\r\n    }\r\n}\r\n"
    },
    "contracts/constants/ConstantsStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nlibrary ConstantsStorage {\r\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"diamond.standard.constants.storage\");\r\n\r\n    struct Layout {\r\n        address collateral;\r\n        uint256 liquidationFee;\r\n        uint256 protocolLiquidationShare;\r\n        uint256 cva;\r\n        uint256 requestTimeout;\r\n        uint256 maxOpenPositionsCross;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/constants/IConstantsEvents.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\ninterface IConstantsEvents {\r\n    event SetCollateral(address oldAddress, address newAddress);\r\n    event SetLiquidationFee(uint256 oldFee, uint256 newFee);\r\n    event SetProtocolLiquidationShare(uint256 oldShare, uint256 newShare);\r\n    event SetCVA(uint256 oldCVA, uint256 newCVA);\r\n    event SetRequestTimeout(uint256 oldTimeout, uint256 newTimeout);\r\n    event SetMaxOpenPositionsCross(uint256 oldMax, uint256 newMax);\r\n}\r\n"
    },
    "contracts/hedgers/HedgersInternal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { HedgersStorage, Hedger } from \"./HedgersStorage.sol\";\r\n\r\nlibrary HedgersInternal {\r\n    using HedgersStorage for HedgersStorage.Layout;\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function getHedgerByAddress(address _hedger) internal view returns (bool success, Hedger memory hedger) {\r\n        hedger = HedgersStorage.layout().hedgerMap[_hedger];\r\n        return hedger.addr == address(0) ? (false, hedger) : (true, hedger);\r\n    }\r\n\r\n    function getHedgerByAddressOrThrow(address partyB) internal view returns (Hedger memory) {\r\n        (bool success, Hedger memory hedger) = getHedgerByAddress(partyB);\r\n        require(success, \"Hedger is not valid\");\r\n        return hedger;\r\n    }\r\n\r\n    function getHedgers() internal view returns (Hedger[] memory hedgerList) {\r\n        return HedgersStorage.layout().hedgerList;\r\n    }\r\n\r\n    function getHedgersLength() internal view returns (uint256 length) {\r\n        return HedgersStorage.layout().hedgerList.length;\r\n    }\r\n}\r\n"
    },
    "contracts/hedgers/HedgersStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nstruct Hedger {\r\n    address addr;\r\n}\r\n\r\nlibrary HedgersStorage {\r\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"diamond.standard.hedgers.storage\");\r\n\r\n    struct Layout {\r\n        mapping(address => Hedger) hedgerMap;\r\n        Hedger[] hedgerList;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibDecimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title Decimal\r\n * @author dYdX\r\n *\r\n * Library that defines a fixed-point number with 18 decimal places.\r\n */\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant BASE = 10 ** 18;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Static Functions ============\r\n\r\n    function zero() internal pure returns (D256 memory) {\r\n        return D256({ value: 0 });\r\n    }\r\n\r\n    function one() internal pure returns (D256 memory) {\r\n        return D256({ value: BASE });\r\n    }\r\n\r\n    function from(uint256 a) internal pure returns (D256 memory) {\r\n        return D256({ value: a.mul(BASE) });\r\n    }\r\n\r\n    function ratio(uint256 a, uint256 b) internal pure returns (D256 memory) {\r\n        return D256({ value: getPartial(a, BASE, b) });\r\n    }\r\n\r\n    // ============ Self Functions ============\r\n\r\n    function add(D256 memory self, uint256 b) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.add(b.mul(BASE)) });\r\n    }\r\n\r\n    function sub(D256 memory self, uint256 b) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.sub(b.mul(BASE)) });\r\n    }\r\n\r\n    function sub(D256 memory self, uint256 b, string memory reason) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.sub(b.mul(BASE), reason) });\r\n    }\r\n\r\n    function mul(D256 memory self, uint256 b) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.mul(b) });\r\n    }\r\n\r\n    function div(D256 memory self, uint256 b) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.div(b) });\r\n    }\r\n\r\n    function pow(D256 memory self, uint256 b) internal pure returns (D256 memory) {\r\n        if (b == 0) {\r\n            return one();\r\n        }\r\n\r\n        D256 memory temp = D256({ value: self.value });\r\n        for (uint256 i = 1; i < b; ++i) {\r\n            temp = mul(temp, self);\r\n        }\r\n\r\n        return temp;\r\n    }\r\n\r\n    function add(D256 memory self, D256 memory b) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.add(b.value) });\r\n    }\r\n\r\n    function sub(D256 memory self, D256 memory b) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.sub(b.value) });\r\n    }\r\n\r\n    function sub(D256 memory self, D256 memory b, string memory reason) internal pure returns (D256 memory) {\r\n        return D256({ value: self.value.sub(b.value, reason) });\r\n    }\r\n\r\n    function mul(D256 memory self, D256 memory b) internal pure returns (D256 memory) {\r\n        return D256({ value: getPartial(self.value, b.value, BASE) });\r\n    }\r\n\r\n    function div(D256 memory self, D256 memory b) internal pure returns (D256 memory) {\r\n        return D256({ value: getPartial(self.value, BASE, b.value) });\r\n    }\r\n\r\n    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\r\n        return self.value == b.value;\r\n    }\r\n\r\n    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\r\n        return compareTo(self, b) == 2;\r\n    }\r\n\r\n    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\r\n        return compareTo(self, b) == 0;\r\n    }\r\n\r\n    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\r\n        return compareTo(self, b) > 0;\r\n    }\r\n\r\n    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\r\n        return compareTo(self, b) < 2;\r\n    }\r\n\r\n    function isZero(D256 memory self) internal pure returns (bool) {\r\n        return self.value == 0;\r\n    }\r\n\r\n    function asUint256(D256 memory self) internal pure returns (uint256) {\r\n        return self.value.div(BASE);\r\n    }\r\n\r\n    // ============ Core Methods ============\r\n\r\n    function getPartial(uint256 target, uint256 numerator, uint256 denominator) private pure returns (uint256) {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    function compareTo(D256 memory a, D256 memory b) private pure returns (uint256) {\r\n        if (a.value == b.value) {\r\n            return 1;\r\n        }\r\n        return a.value > b.value ? 2 : 0;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibEnums.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nenum MarketType {\r\n    FOREX,\r\n    METALS,\r\n    ENERGIES,\r\n    INDICES,\r\n    STOCKS,\r\n    COMMODITIES,\r\n    BONDS,\r\n    ETFS,\r\n    CRYPTO\r\n}\r\n\r\nenum Side {\r\n    BUY,\r\n    SELL\r\n}\r\n\r\nenum HedgerMode {\r\n    SINGLE,\r\n    HYBRID,\r\n    AUTO\r\n}\r\n\r\nenum OrderType {\r\n    LIMIT,\r\n    MARKET\r\n}\r\n\r\nenum PositionType {\r\n    ISOLATED,\r\n    CROSS\r\n}\r\n"
    },
    "contracts/markets/MarketsInternal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { Decimal } from \"../libraries/LibDecimal.sol\";\r\nimport { ConstantsInternal } from \"../constants/ConstantsInternal.sol\";\r\nimport { MarketsStorage, Market } from \"./MarketsStorage.sol\";\r\nimport { MasterStorage } from \"../master-agreement/MasterStorage.sol\";\r\n\r\nlibrary MarketsInternal {\r\n    using MarketsStorage for MarketsStorage.Layout;\r\n    using MasterStorage for MasterStorage.Layout;\r\n    using Decimal for Decimal.D256;\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function getMarkets() internal view returns (Market[] memory markets) {\r\n        return MarketsStorage.layout().marketList;\r\n    }\r\n\r\n    function getMarketById(uint256 marketId) internal view returns (Market memory market) {\r\n        return MarketsStorage.layout().marketMap[marketId];\r\n    }\r\n\r\n    function getMarketsByIds(uint256[] memory marketIds) internal view returns (Market[] memory markets) {\r\n        markets = new Market[](marketIds.length);\r\n        for (uint256 i = 0; i < marketIds.length; i++) {\r\n            markets[i] = MarketsStorage.layout().marketMap[marketIds[i]];\r\n        }\r\n    }\r\n\r\n    function getMarketsInRange(uint256 start, uint256 end) internal view returns (Market[] memory markets) {\r\n        uint256 length = end - start;\r\n        markets = new Market[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            markets[i] = MarketsStorage.layout().marketList[start + i];\r\n        }\r\n    }\r\n\r\n    function getMarketsLength() internal view returns (uint256 length) {\r\n        return MarketsStorage.layout().marketList.length;\r\n    }\r\n\r\n    function getMarketFromPositionId(uint256 positionId) internal view returns (Market memory market) {\r\n        uint256 marketId = MasterStorage.layout().allPositionsMap[positionId].marketId;\r\n        market = MarketsStorage.layout().marketMap[marketId];\r\n    }\r\n\r\n    function getMarketsFromPositionIds(uint256[] calldata positionIds) internal view returns (Market[] memory markets) {\r\n        markets = new Market[](positionIds.length);\r\n        for (uint256 i = 0; i < positionIds.length; i++) {\r\n            uint256 marketId = MasterStorage.layout().allPositionsMap[positionIds[i]].marketId;\r\n            markets[i] = MarketsStorage.layout().marketMap[marketId];\r\n        }\r\n    }\r\n\r\n    function getMarketProtocolFee(uint256 marketId) internal view returns (Decimal.D256 memory) {\r\n        uint256 fee = MarketsStorage.layout().marketMap[marketId].protocolFee;\r\n        return Decimal.ratio(fee, ConstantsInternal.getPercentBase());\r\n    }\r\n\r\n    function isValidMarketId(uint256 marketId) internal pure returns (bool) {\r\n        return marketId > 0;\r\n    }\r\n\r\n    function isActiveMarket(uint256 marketId) internal view returns (bool) {\r\n        return MarketsStorage.layout().marketMap[marketId].active;\r\n    }\r\n}\r\n"
    },
    "contracts/markets/MarketsStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { MarketType } from \"../libraries/LibEnums.sol\";\r\n\r\nstruct Market {\r\n    uint256 marketId;\r\n    string identifier;\r\n    MarketType marketType;\r\n    bool active;\r\n    string baseCurrency;\r\n    string quoteCurrency;\r\n    string symbol;\r\n    bytes32 muonPriceFeedId;\r\n    bytes32 fundingRateId;\r\n    uint256 protocolFee;\r\n}\r\n\r\nlibrary MarketsStorage {\r\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"diamond.standard.markets.storage\");\r\n\r\n    struct Layout {\r\n        mapping(uint256 => Market) marketMap;\r\n        Market[] marketList;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/master-agreement/MasterCalculators.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { Side } from \"../libraries/LibEnums.sol\";\r\nimport { Decimal } from \"../libraries/LibDecimal.sol\";\r\nimport { PositionPrice } from \"../oracle/OracleStorage.sol\";\r\nimport { ConstantsInternal } from \"../constants/ConstantsInternal.sol\";\r\nimport { MarketsInternal } from \"../markets/MarketsInternal.sol\";\r\nimport { MasterStorage, Position } from \"./MasterStorage.sol\";\r\n\r\nlibrary MasterCalculators {\r\n    using Decimal for Decimal.D256;\r\n    using MasterStorage for MasterStorage.Layout;\r\n\r\n    /**\r\n     * @notice Returns the UPnL for a specific position.\r\n     * @dev This is a naive function, inputs can not be trusted. Use cautiously.\r\n     */\r\n    function calculateUPnLIsolated(\r\n        uint256 positionId,\r\n        uint256 bidPrice,\r\n        uint256 askPrice\r\n    ) internal view returns (int256 uPnLA, int256 uPnLB) {\r\n        MasterStorage.Layout storage s = MasterStorage.layout();\r\n        Position memory position = s.allPositionsMap[positionId];\r\n\r\n        (uPnLA, uPnLB) = _calculateUPnLIsolated(\r\n            position.side,\r\n            position.currentBalanceUnits,\r\n            position.initialNotionalUsd,\r\n            bidPrice,\r\n            askPrice\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the UPnL of a party across all his open positions.\r\n     * @dev This is a naive function, inputs can NOT be trusted. Use cautiously.\r\n     *      Use Muon to verify inputs to prevent expensive computational costs.\r\n     * @dev positionPrices can have an incorrect length.\r\n     * @dev positionPrices can have an arbitrary order.\r\n     * @dev positionPrices can contain forged duplicates.\r\n     */\r\n    function calculateUPnLCross(\r\n        PositionPrice[] memory positionPrices,\r\n        address party\r\n    ) internal view returns (int256 uPnLCross) {\r\n        return _calculateUPnLCross(positionPrices, party);\r\n    }\r\n\r\n    function calculateProtocolFeeAmount(uint256 marketId, uint256 notionalUsd) internal view returns (uint256) {\r\n        return Decimal.from(notionalUsd).mul(MarketsInternal.getMarketProtocolFee(marketId)).asUint256();\r\n    }\r\n\r\n    function calculateLiquidationFeeAmount(uint256 notionalUsd) internal view returns (uint256) {\r\n        return Decimal.from(notionalUsd).mul(ConstantsInternal.getLiquidationFee()).asUint256();\r\n    }\r\n\r\n    function calculateCVAAmount(uint256 notionalSize) internal view returns (uint256) {\r\n        return Decimal.from(notionalSize).mul(ConstantsInternal.getCVA()).asUint256();\r\n    }\r\n\r\n    function calculateCrossMarginHealth(\r\n        address party,\r\n        int256 uPnLCross\r\n    ) internal view returns (Decimal.D256 memory ratio) {\r\n        MasterStorage.Layout storage s = MasterStorage.layout();\r\n\r\n        uint256 lockedMargin = s.crossLockedMargin[party];\r\n        uint256 openPositions = s.openPositionsCrossLength[party];\r\n\r\n        if (lockedMargin == 0 && openPositions == 0) {\r\n            return Decimal.ratio(1, 1);\r\n        } else if (lockedMargin == 0) {\r\n            return Decimal.zero();\r\n        }\r\n\r\n        if (uPnLCross >= 0) {\r\n            return Decimal.ratio(lockedMargin + uint256(uPnLCross), lockedMargin);\r\n        }\r\n\r\n        uint256 pnl = uint256(-uPnLCross);\r\n        if (pnl >= lockedMargin) {\r\n            return Decimal.zero();\r\n        }\r\n\r\n        ratio = Decimal.ratio(lockedMargin - pnl, lockedMargin);\r\n    }\r\n\r\n    /* ========== PRIVATE ========== */\r\n\r\n    /**\r\n     * @notice Returns the UPnL for a specific position.\r\n     * @dev This is a naive function, inputs can not be trusted. Use cautiously.\r\n     */\r\n    function _calculateUPnLIsolated(\r\n        Side side,\r\n        uint256 currentBalanceUnits,\r\n        uint256 initialNotionalUsd,\r\n        uint256 bidPrice,\r\n        uint256 askPrice\r\n    ) private pure returns (int256 uPnLA, int256 uPnLB) {\r\n        if (currentBalanceUnits == 0) return (0, 0);\r\n\r\n        uint256 precision = ConstantsInternal.getPrecision();\r\n        if (side == Side.BUY) {\r\n            require(bidPrice != 0, \"Oracle bidPrice is invalid\");\r\n            int256 notionalIsolatedA = int256((currentBalanceUnits * bidPrice) / precision);\r\n            uPnLA = notionalIsolatedA - int256(initialNotionalUsd);\r\n        } else {\r\n            require(askPrice != 0, \"Oracle askPrice is invalid\");\r\n            int256 notionalIsolatedA = int256((currentBalanceUnits * askPrice) / precision);\r\n            uPnLA = int256(initialNotionalUsd) - notionalIsolatedA;\r\n        }\r\n\r\n        return (uPnLA, -uPnLA);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the UPnL of a party across all his open positions.\r\n     * @dev This is a naive function, inputs can NOT be trusted. Use cautiously.\r\n     * @dev positionPrices can have an incorrect length.\r\n     * @dev positionPrices can have an arbitrary order.\r\n     * @dev positionPrices can contain forged duplicates.\r\n     */\r\n    function _calculateUPnLCross(\r\n        PositionPrice[] memory positionPrices,\r\n        address party\r\n    ) private view returns (int256 uPnLCrossA) {\r\n        MasterStorage.Layout storage s = MasterStorage.layout();\r\n\r\n        for (uint256 i = 0; i < positionPrices.length; i++) {\r\n            uint256 positionId = positionPrices[i].positionId;\r\n            uint256 bidPrice = positionPrices[i].bidPrice;\r\n            uint256 askPrice = positionPrices[i].askPrice;\r\n\r\n            Position memory position = s.allPositionsMap[positionId];\r\n            require(position.partyA == party, \"PositionId mismatch\");\r\n\r\n            (int256 _uPnLIsolatedA, ) = _calculateUPnLIsolated(\r\n                position.side,\r\n                position.currentBalanceUnits,\r\n                position.initialNotionalUsd,\r\n                bidPrice,\r\n                askPrice\r\n            );\r\n\r\n            uPnLCrossA += _uPnLIsolatedA;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/master-agreement/MasterStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { PositionType, OrderType, HedgerMode, Side } from \"../libraries/LibEnums.sol\";\r\n\r\nenum RequestForQuoteState {\r\n    NEW,\r\n    CANCELED,\r\n    ACCEPTED\r\n}\r\n\r\nenum PositionState {\r\n    OPEN,\r\n    MARKET_CLOSE_REQUESTED,\r\n    LIMIT_CLOSE_REQUESTED,\r\n    LIMIT_CLOSE_ACTIVE,\r\n    CLOSED,\r\n    LIQUIDATED\r\n    // TODO: add cancel limit close\r\n}\r\n\r\nstruct RequestForQuote {\r\n    uint256 creationTimestamp;\r\n    uint256 mutableTimestamp;\r\n    uint256 rfqId;\r\n    RequestForQuoteState state;\r\n    PositionType positionType;\r\n    OrderType orderType;\r\n    address partyA;\r\n    address partyB;\r\n    HedgerMode hedgerMode;\r\n    uint256 marketId;\r\n    Side side;\r\n    uint256 notionalUsd;\r\n    uint256 lockedMarginA;\r\n    uint256 protocolFee;\r\n    uint256 liquidationFee;\r\n    uint256 cva;\r\n    uint256 minExpectedUnits;\r\n    uint256 maxExpectedUnits;\r\n    address affiliate;\r\n}\r\n\r\nstruct Position {\r\n    uint256 creationTimestamp;\r\n    uint256 mutableTimestamp;\r\n    uint256 positionId;\r\n    bytes16 uuid;\r\n    PositionState state;\r\n    PositionType positionType;\r\n    uint256 marketId;\r\n    address partyA;\r\n    address partyB;\r\n    Side side;\r\n    uint256 lockedMarginA;\r\n    uint256 lockedMarginB;\r\n    uint256 protocolFeePaid;\r\n    uint256 liquidationFee;\r\n    uint256 cva;\r\n    uint256 currentBalanceUnits;\r\n    uint256 initialNotionalUsd;\r\n    address affiliate;\r\n}\r\n\r\nlibrary MasterStorage {\r\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"diamond.standard.master.agreement.storage\");\r\n\r\n    struct Layout {\r\n        // Balances\r\n        mapping(address => uint256) accountBalances;\r\n        mapping(address => uint256) marginBalances;\r\n        mapping(address => uint256) crossLockedMargin;\r\n        mapping(address => uint256) crossLockedMarginReserved;\r\n        // RequestForQuotes\r\n        mapping(uint256 => RequestForQuote) requestForQuotesMap;\r\n        uint256 requestForQuotesLength;\r\n        mapping(address => uint256) crossRequestForQuotesLength;\r\n        // Positions\r\n        mapping(uint256 => Position) allPositionsMap;\r\n        uint256 allPositionsLength;\r\n        mapping(address => uint256) openPositionsIsolatedLength;\r\n        mapping(address => uint256) openPositionsCrossLength;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/master-agreement/trading/IOpenEvents.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\ninterface IOpenEvents {\r\n    event RequestForQuoteNew(uint256 indexed rfqId, address partyA, address partyB);\r\n    event RequestForQuoteCanceled(uint256 indexed rfqId, address partyA, address partyB);\r\n    event OpenPosition(\r\n        uint256 indexed rfqId,\r\n        uint256 indexed positionId,\r\n        address partyA,\r\n        address partyB,\r\n        uint256 amountUnits,\r\n        uint256 avgPriceUsd\r\n    );\r\n}\r\n"
    },
    "contracts/master-agreement/trading/OpenBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { PositionType, OrderType, HedgerMode, Side } from \"../../libraries/LibEnums.sol\";\r\nimport { MarketsInternal } from \"../../markets/MarketsInternal.sol\";\r\nimport { ConstantsInternal } from \"../../constants/ConstantsInternal.sol\";\r\nimport { MasterStorage, RequestForQuote, RequestForQuoteState, Position, PositionState } from \"../MasterStorage.sol\";\r\nimport { MasterCalculators } from \"../MasterCalculators.sol\";\r\nimport { IOpenEvents } from \"./IOpenEvents.sol\";\r\n\r\nabstract contract OpenBase is IOpenEvents {\r\n    using MasterStorage for MasterStorage.Layout;\r\n\r\n    function _onRequestForQuote(\r\n        address partyA,\r\n        address partyB,\r\n        uint256 marketId,\r\n        PositionType positionType,\r\n        OrderType orderType,\r\n        HedgerMode hedgerMode,\r\n        Side side,\r\n        uint256 usdAmountToSpend,\r\n        uint16 leverage,\r\n        uint256 minExpectedUnits,\r\n        uint256 maxExpectedUnits,\r\n        address affiliate\r\n    ) internal returns (RequestForQuote memory rfq) {\r\n        MasterStorage.Layout storage s = MasterStorage.layout();\r\n\r\n        // This inherently validates the existence of a market as well.\r\n        require(MarketsInternal.isActiveMarket(marketId), \"Market not active\");\r\n\r\n        if (positionType == PositionType.CROSS) {\r\n            uint256 numOpenPositionsCross = s.openPositionsCrossLength[partyA];\r\n            uint256 numOpenRfqsCross = s.crossRequestForQuotesLength[partyA];\r\n            require(\r\n                numOpenPositionsCross + numOpenRfqsCross < ConstantsInternal.getMaxOpenPositionsCross(),\r\n                \"Max open positions cross reached\"\r\n            );\r\n        }\r\n\r\n        require(usdAmountToSpend > 0, \"Amount cannot be zero\");\r\n        uint256 notionalUsd = usdAmountToSpend * leverage;\r\n        uint256 protocolFee = MasterCalculators.calculateProtocolFeeAmount(marketId, notionalUsd);\r\n        uint256 liquidationFee = MasterCalculators.calculateLiquidationFeeAmount(notionalUsd);\r\n        uint256 cva = MasterCalculators.calculateCVAAmount(notionalUsd);\r\n        uint256 amount = usdAmountToSpend + protocolFee + liquidationFee + cva;\r\n\r\n        require(amount <= s.marginBalances[partyA], \"Insufficient margin balance\");\r\n        s.marginBalances[partyA] -= amount;\r\n        s.crossLockedMarginReserved[partyA] += amount;\r\n\r\n        // Create the RFQ\r\n        uint256 currentRfqId = s.requestForQuotesLength + 1;\r\n        rfq = RequestForQuote({\r\n            creationTimestamp: block.timestamp,\r\n            mutableTimestamp: block.timestamp,\r\n            rfqId: currentRfqId,\r\n            state: RequestForQuoteState.NEW,\r\n            positionType: positionType,\r\n            orderType: orderType,\r\n            partyA: partyA,\r\n            partyB: partyB,\r\n            hedgerMode: hedgerMode,\r\n            marketId: marketId,\r\n            side: side,\r\n            notionalUsd: notionalUsd,\r\n            lockedMarginA: usdAmountToSpend,\r\n            protocolFee: protocolFee,\r\n            liquidationFee: liquidationFee,\r\n            cva: cva,\r\n            minExpectedUnits: minExpectedUnits,\r\n            maxExpectedUnits: maxExpectedUnits,\r\n            affiliate: affiliate\r\n        });\r\n\r\n        s.requestForQuotesMap[currentRfqId] = rfq;\r\n        s.requestForQuotesLength++;\r\n\r\n        // Increase the number of active RFQs\r\n        if (positionType == PositionType.CROSS) {\r\n            s.crossRequestForQuotesLength[partyA]++;\r\n        }\r\n    }\r\n\r\n    function _openPositionMarket(\r\n        address partyB,\r\n        uint256 rfqId,\r\n        uint256 filledAmountUnits,\r\n        bytes16 uuid,\r\n        uint256 lockedMarginB\r\n    ) internal returns (Position memory position) {\r\n        MasterStorage.Layout storage s = MasterStorage.layout();\r\n        RequestForQuote storage rfq = s.requestForQuotesMap[rfqId];\r\n\r\n        require(rfq.state == RequestForQuoteState.NEW, \"Invalid RFQ state\");\r\n        require(rfq.minExpectedUnits <= filledAmountUnits, \"Invalid min filled amount\");\r\n        require(rfq.maxExpectedUnits >= filledAmountUnits, \"Invalid max filled amount\");\r\n\r\n        // Update the RFQ\r\n        _updateRequestForQuoteState(rfq, RequestForQuoteState.ACCEPTED);\r\n\r\n        // Create the Position\r\n        uint256 currentPositionId = s.allPositionsLength + 1;\r\n        position = Position({\r\n            creationTimestamp: block.timestamp,\r\n            mutableTimestamp: block.timestamp,\r\n            positionId: currentPositionId,\r\n            uuid: uuid,\r\n            state: PositionState.OPEN,\r\n            positionType: rfq.positionType,\r\n            marketId: rfq.marketId,\r\n            partyA: rfq.partyA,\r\n            partyB: rfq.partyB,\r\n            side: rfq.side,\r\n            lockedMarginA: rfq.lockedMarginA,\r\n            lockedMarginB: lockedMarginB,\r\n            protocolFeePaid: rfq.protocolFee,\r\n            liquidationFee: rfq.liquidationFee,\r\n            cva: rfq.cva,\r\n            currentBalanceUnits: filledAmountUnits,\r\n            initialNotionalUsd: rfq.notionalUsd,\r\n            affiliate: rfq.affiliate\r\n        });\r\n\r\n        // Update global mappings\r\n        s.allPositionsMap[currentPositionId] = position;\r\n        s.allPositionsLength++;\r\n\r\n        // Transfer partyA's collateral\r\n        uint256 deductableMarginA = rfq.lockedMarginA + rfq.protocolFee + rfq.liquidationFee + rfq.cva;\r\n        s.crossLockedMarginReserved[rfq.partyA] -= deductableMarginA;\r\n\r\n        // Transfer partyB's collateral\r\n        uint256 deductableMarginB = lockedMarginB + rfq.liquidationFee + rfq.cva; // hedger doesn't pay protocolFee\r\n        require(deductableMarginB <= s.marginBalances[partyB], \"Insufficient margin balance\");\r\n        s.marginBalances[partyB] -= deductableMarginB;\r\n\r\n        // Collect the fee paid by partyA\r\n        s.accountBalances[address(this)] += rfq.protocolFee;\r\n\r\n        if (rfq.positionType == PositionType.ISOLATED) {\r\n            s.openPositionsIsolatedLength[rfq.partyA]++;\r\n            s.openPositionsIsolatedLength[partyB]++;\r\n        } else {\r\n            s.openPositionsCrossLength[rfq.partyA]++;\r\n            s.openPositionsIsolatedLength[partyB]++;\r\n\r\n            // Lock margins\r\n            s.crossLockedMargin[rfq.partyA] += rfq.lockedMarginA;\r\n            s.crossLockedMargin[partyB] += lockedMarginB;\r\n\r\n            // Decrease the number of active RFQs\r\n            s.crossRequestForQuotesLength[rfq.partyA]--;\r\n        }\r\n    }\r\n\r\n    function _updateRequestForQuoteState(RequestForQuote storage rfq, RequestForQuoteState state) internal {\r\n        rfq.state = state;\r\n        rfq.mutableTimestamp = block.timestamp;\r\n    }\r\n\r\n    function _cancelRequestForQuote(RequestForQuote memory rfq) internal {\r\n        MasterStorage.Layout storage s = MasterStorage.layout();\r\n\r\n        // Return user funds\r\n        uint256 reservedMargin = rfq.lockedMarginA + rfq.protocolFee + rfq.liquidationFee + rfq.cva;\r\n        s.crossLockedMarginReserved[rfq.partyA] -= reservedMargin;\r\n        s.marginBalances[rfq.partyA] += reservedMargin;\r\n\r\n        // Decrease the number of active RFQs\r\n        if (rfq.positionType == PositionType.CROSS) {\r\n            s.crossRequestForQuotesLength[rfq.partyA]--;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/master-agreement/trading/OpenMarketSingle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { PositionType, Side, OrderType, HedgerMode } from \"../../libraries/LibEnums.sol\";\r\nimport { HedgersInternal } from \"../../hedgers/HedgersInternal.sol\";\r\nimport { ConstantsInternal } from \"../../constants/ConstantsInternal.sol\";\r\nimport { MasterStorage, RequestForQuote, RequestForQuoteState } from \"../MasterStorage.sol\";\r\nimport { OpenBase } from \"./OpenBase.sol\";\r\n\r\ncontract OpenMarketSingle is OpenBase {\r\n    using MasterStorage for MasterStorage.Layout;\r\n\r\n    function requestOpenMarketSingle(\r\n        address partyB,\r\n        uint256 marketId,\r\n        PositionType positionType,\r\n        Side side,\r\n        uint256 usdAmountToSpend,\r\n        uint16 leverage,\r\n        uint256[2] memory expectedUnits,\r\n        address affiliate\r\n    ) external returns (RequestForQuote memory rfq) {\r\n        require(msg.sender != partyB, \"Parties can not be the same\");\r\n        HedgersInternal.getHedgerByAddressOrThrow(partyB);\r\n\r\n        rfq = _onRequestForQuote(\r\n            msg.sender,\r\n            partyB,\r\n            marketId,\r\n            positionType,\r\n            OrderType.MARKET,\r\n            HedgerMode.SINGLE,\r\n            side,\r\n            usdAmountToSpend,\r\n            leverage,\r\n            expectedUnits[0],\r\n            expectedUnits[1],\r\n            affiliate\r\n        );\r\n\r\n        emit RequestForQuoteNew(rfq.rfqId, msg.sender, partyB);\r\n    }\r\n\r\n    function cancelOpenMarketSingle(uint256 rfqId) public {\r\n        RequestForQuote storage rfq = MasterStorage.layout().requestForQuotesMap[rfqId];\r\n\r\n        require(rfq.partyA == msg.sender, \"Invalid party\");\r\n        require(rfq.orderType == OrderType.MARKET, \"Invalid order type\");\r\n        require(rfq.hedgerMode == HedgerMode.SINGLE, \"Invalid hedger mode\");\r\n        require(rfq.state == RequestForQuoteState.NEW, \"Invalid RFQ state\");\r\n        require(rfq.mutableTimestamp + ConstantsInternal.getRequestTimeout() < block.timestamp, \"Request Timeout\");\r\n\r\n        _updateRequestForQuoteState(rfq, RequestForQuoteState.CANCELED);\r\n        _cancelRequestForQuote(rfq);\r\n\r\n        emit RequestForQuoteCanceled(rfqId, msg.sender, rfq.partyB);\r\n    }\r\n\r\n    function cancelAllOpenMarketSingle(uint256[] calldata rfqIds) external {\r\n        for (uint256 i = 0; i < rfqIds.length; i++) {\r\n            cancelOpenMarketSingle(rfqIds[i]);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/master-agreement/trading/OpenPosition.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nimport { OrderType, HedgerMode } from \"../../libraries/LibEnums.sol\";\r\nimport { MasterStorage, RequestForQuote, Position } from \"../MasterStorage.sol\";\r\nimport { OpenBase } from \"./OpenBase.sol\";\r\n\r\ncontract OpenPosition is OpenBase {\r\n    using MasterStorage for MasterStorage.Layout;\r\n\r\n    function openPosition(\r\n        uint256 rfqId,\r\n        uint256 filledAmountUnits,\r\n        uint256 avgPriceUsd,\r\n        bytes16 uuid,\r\n        uint256 lockedMarginB\r\n    ) external returns (Position memory position) {\r\n        RequestForQuote storage rfq = MasterStorage.layout().requestForQuotesMap[rfqId];\r\n\r\n        if (rfq.hedgerMode == HedgerMode.SINGLE && rfq.orderType == OrderType.MARKET) {\r\n            position = _openPositionMarketSingle(rfq, filledAmountUnits, uuid, lockedMarginB);\r\n        } else {\r\n            revert(\"Other modes not implemented yet\");\r\n        }\r\n\r\n        emit OpenPosition(rfq.rfqId, position.positionId, rfq.partyA, rfq.partyB, filledAmountUnits, avgPriceUsd);\r\n    }\r\n\r\n    function _openPositionMarketSingle(\r\n        RequestForQuote memory rfq,\r\n        uint256 filledAmountUnits,\r\n        bytes16 uuid,\r\n        uint256 lockedMarginB\r\n    ) private returns (Position memory position) {\r\n        require(rfq.partyB == msg.sender, \"Invalid party\");\r\n        return _openPositionMarket(msg.sender, rfq.rfqId, filledAmountUnits, uuid, lockedMarginB);\r\n    }\r\n}\r\n"
    },
    "contracts/oracle/OracleStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.16;\r\n\r\nstruct SchnorrSign {\r\n    uint256 signature;\r\n    address owner;\r\n    address nonce;\r\n}\r\n\r\nstruct PublicKey {\r\n    uint256 x;\r\n    uint8 parity;\r\n}\r\n\r\nstruct PositionPrice {\r\n    uint256 positionId;\r\n    uint256 bidPrice;\r\n    uint256 askPrice;\r\n}\r\n\r\nlibrary OracleStorage {\r\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"diamond.standard.oracle.storage\");\r\n\r\n    struct Layout {\r\n        uint256 muonAppId;\r\n        bytes muonAppCID;\r\n        PublicKey muonPublicKey;\r\n        address muonGatewaySigner;\r\n        uint256 signatureExpiryPeriod;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    }
  }
}
